load ../../tool2 .
load onethirdrule .

mod MODEL is
    ---pr ONETHIRDRULE .
    pr ONETHIRDRULE-NO-MSG-LOSS .
    pr SATISFACTION .

    subsorts Global < State .

    vars O O' : Oid . vars CF : Configuration . var C : Cid .
    vars OS OS' : OidSet . 
    var R TH N VA : Nat .
    var VS : ValueSet .
    var S : State .
    var MSG : Msg .
    vars ATTS ATTS' : AttributeSet .
    vars V V' : Value .
    var VM : VoteMap .
    var VOTE : Vote .

    op disagree : -> Prop [ctor] .
    eq { TH, VS, OS, < O : Node | decision : 0, ATTS > < O' : Node | decision : 1, ATTS' > CF } |= disagree = true .
    eq S |= disagree = false [owise] .

    op hasDec : Nat -> Prop [ctor] .
    eq { TH, VS, OS, < O : Node | decision : D:Value?, ATTS > CF } |= hasDec(D:Value?) = true .
    eq S |= hasDec(D:Value?) = false [owise] .

    --- experimental
    op voteLHS : Value -> Prop [ctor] .
    eq {TH, V ; VS, O ; OS,
        < O : Node | status : [R, init], value : V, decision : nilValue, votes : VOTE, ATTS > 
        CF
    } |= voteLHS(V) = true .
    eq S |= voteLHS(V) = false [owise] .

    ---op voteRHS : Value -> Prop [ctor] .
    ---eq {TH, V ; VS, O ; OS,
    ---    < O : Node | status : [R, wait], value : V, decision : nilValue, votes : update(VOTE, V), ATTS > 
    ---    (multicast vote(V, R) from O to OS)
    ---    CF
    ---} |= voteRHS(V) = true .

    op receiveLHS : Value -> Prop [ctor] .
    eq {TH, V ; VS, OS,
        < O : Node | status : [R, wait], decision : nilValue, votes : VOTE, ATTS > 
        (multicast vote(V, R) from O' to (O ; OS'))
        CF
    } |= receiveLHS(V) = true .
    eq S |= receiveLHS(V) = false [owise] .

    ---op receiveLHS : Value -> Prop [ctor] .
    ---eq {TH, V ; VS, OS,
    ---    < O : Node | status : [R, wait], decision : nilValue, votes : update(VOTE, V), ATTS > 
    ---    (multicast vote(V, R) from O' to OS')  
    ---    CF
    ---}  |= receiveRHS(V) = true .

    op decideRHS : Value -> Prop [ctor] .
    eq {TH, VS, OS,
        < O : Node | status : [R, done], decision : V, votes : [(V |-> N ; VM), VA], ATTS >
        CF
    } |= decideRHS(V) = true .
    eq S |= decideRHS(V) = false [owise] .

    op updateLHS : Value Value -> Prop [ctor] .
   ceq {TH, V' ; VS, OS,
        < O : Node | status : [R, wait], value : V, decision : nilValue, votes : [V' |-> N ; VM, VA], ATTS >
        CF
    } |= updateLHS(V, V') = true if (N < TH) and (TH <= VA) and genConst(V', N, VM, VS) .
    eq S |= updateLHS(V, V') = false [owise] .


    ---op updateRHS : Value Value -> Prop [ctor] .
    ---eq {TH, V' ; VS, OS,
    ---    < O : Node | status : [s R, init], value : V', decision : nilValue, votes : [initVotes(V' ; VS), 0], ATTS >
    ---    CF
    ---} |= updateRHS(V, V') = true .
    ---eq S |= hasDec(D:Value?) = false [owise] .
endm